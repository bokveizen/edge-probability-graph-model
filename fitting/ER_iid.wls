#!/usr/bin/env wolframscript
(* ::Package:: *)

(* ::Input:: *)
(*(* Fix n and p, only optimize alpha to fit the number of triangles or the triangle-wedge ratio *)*)


(* ::Input:: *)
(*nDict=<|"facebook"->4039,"hamsterster"->2000,"polblogs"->1222,"web-spam"->4767,"bio-CE-PG"->1692,"bio-SC-HT"->2077|>;*)
(*mDict=<|"facebook"->88234,"hamsterster"->16097,"polblogs"->16717,"web-spam"->37375,"bio-CE-PG"->47309,"bio-SC-HT"->63023|>;*)
(*tDict=<|"facebook"->4478819,"hamsterster"->530606,"polblogs"->1038613,"web-spam"->2278717,"bio-CE-PG"->4982692,"bio-SC-HT"->6940974|>;*)
(*TDict=<|"facebook"->4836030,"hamsterster"->157953,"polblogs"->303129,"web-spam"->387051,"bio-CE-PG"->2353812,"bio-SC-HT"->4192980|>;*)
(*dataset="facebook";*)
(*n0=nDict[dataset];*)
(*m0=mDict[dataset];*)
(*t0 =tDict[dataset];*)
(*T0=TDict[dataset]/3;*)
(*ratio0=T0/t0;*)
(*R0=100000;*)


(* ::Input:: *)
(*$MinPrecision=50;*)
(*$MaxPrecision=50;*)
(*Clear[n,m,a,R,p,r,c,d,X,P0,P1,P2,P3,Y];*)
(*p[n_,m_]:=m/(n*(n-1)/2);*)
(*r[n_,m_,a_,R_]:=(1-((1-p[n,m])^(1/R)))/(a*a);*)
(*c[n_,m_,a_,R_]:=a*(1-((1-a)^(n-1)))*r[n,m,a,R];*)
(*d[n_,m_,a_,R_]:=1-(1-c[n,m,a,R])^R;*)
(*X[n_,m_,a_,R_]:=n*d[n,m,a,R];  (* The number of edges *)*)
(*P0[n_,m_,a_,R_]:=(1-r[n,m,a,R]*(a^3)-3*a*a*(1-a)*r[n,m,a,R])^R;*)
(*P1[n_,m_,a_,R_]:=(1-r[n,m,a,R]*(a^3)-2*a*a*(1-a)*r[n,m,a,R])^R-P0[n,m,a,R];*)
(*P2[n_,m_,a_,R_]:=(1-r[n,m,a,R]*(a^3)-a*a*(1-a)*r[n,m,a,R])^R-(2*P1[n,m,a,R])-P0[n,m,a,R];*)
(*P3[n_,m_,a_,R_]:=1-P0[n,m,a,R]-(3*P1[n,m,a,R])-(3*P2[n,m,a,R]);*)
(*Y[n_,m_,a_,R_]:=Binomial[n,3]*P3[n,m,a,R]; (* The number of triangles *)*)
(*Z[n_,m_,a_,R_]:=Binomial[n,3]*P2[n,m,a,R]*3;(* The number of open wedges *)*)
(*YZratio[n_,m_,a_,R_]:=Y[n,m,a,R]/Z[n,m,a,R]; *)
(*p0=p[n0,m0];*)


(* ::Input:: *)
(*nL={};aL={};TL={};rL={};*)
(*nxMin = Round[n0*1.01];*)
(*nxMax = n0 * 2;*)
(*startTime=AbsoluteTime[];*)
(*Monitor[*)
(*For[nx=nxMin,nx<=nxMax,nx++,*)
(*{ax=ax/.FindRoot[X[nx,m0,ax,R0]==n0,{ax,0.001},WorkingPrecision->50];*)
(*Tx=Y[nx,m0,ax,R0];*)
(*If[Tx > T0, Break[]];*)
(*rx=r[nx,m0,ax,R0];*)
(*AppendTo[aL,ax];*)
(*AppendTo[nL,nx];*)
(*AppendTo[TL,Tx];*)
(*AppendTo[rL,rx]}],*)
(*ProgressIndicator[nx,{nxMin,nxMax}]*)
(*]*)
(*(* Find the alpha to fit the expected number of triangles *)*)
(*axT=a/.FindRoot[Y[n0,m0,a,R0]==T0,{a,0.001},WorkingPrecision->50];*)
(*rT = r[n0, m0, axT,R0];*)
(*(* Find the alpha to fit the closed-triangle ratio *)*)
(*axR = a /. FindRoot[YZratio[n0,m0,a,R0]==ratio0,{a,0.001},WorkingPrecision->50];*)
(*rR = r[n0,m0,axR,R0];*)


(* ::Input:: *)
(*Print[n0, " ", NumberForm[N[p0,50]]," ", NumberForm[N[axT,50]], " ", R0, " ", NumberForm[N[rT,50]]];Print[n0, " ", NumberForm[N[p0,50]]," ", NumberForm[N[axR,50]], " ", R0, " ", NumberForm[N[rR,50]]];*)
(*nearest=Nearest[TL,T0][[1]];(*Get the nearest number*)*)
(*index=Position[TL,nearest][[1,1]];(*Get the index of the nearest number*)*)
(*Print[nL[[index]]," ",NumberForm[N[p[nL[[index]],m0],50]]," ", NumberForm[aL[[index]],50]," ", R0, " ", NumberForm[N[rL[[index]],50]]]*)
(**)



